---
title: "Decomposing time series with complex seasonality"
author: Rob J Hyndman
institute: "<img src='figs/monash_bw.png' width='25%'>"
abstract: "Time series data often contain a rich complexity of seasonal patterns. Time series that are observed at a sub-daily level can exhibit multiple seasonal patterns corresponding to different granularities such as hour-of-the-day, day-of-the-week or month-of-the-year. They can be nested (e.g., hour-of-the-day within day-of-the-week) and non-nested (e.g., day-of-the-year in both the Gregorian and Hijri calendars). I will discuss two new time series decomposition tools for handling seasonalities in time series data: MSTL and STR. These allow for multiple seasonal and cyclic components, covariates, seasonal patterns that may have non-integer periods, and seasonality with complex topology. They can be used for time series with any regular time index including hourly, daily, weekly, monthly or quarterly data, but tackle many more decomposition problems than other methods allow."
time: 20 mins
format:
  revealjs:
    slide-number: "c"
    preview-links: auto
    fig-format: svg
    controls: true
    theme: [default, custom.scss]
    html-math-method: katex
---

## Complex seasonality

```{r}
# Load packages needed later
library(tidyverse)
library(dygraphs)
library(fpp3)
library(gt)
library(fontawesome)

# Colours to be viridis for continuous scales and Okabe for discrete scales
options(
  digits = 4,
  ggplot2.continuous.colour = "viridis",
  ggplot2.continuous.fill = "viridis",
  ggplot2.discrete.colour = c("#009E73", "#E69F00", "#56B4E9", "#F0E442", "#CC79A7"),
  ggplot2.discrete.fill = c("#009E73", "#E69F00", "#56B4E9", "#F0E442", "#CC79A7")
)
ggplot2::theme_set(theme_get() + theme(text = element_text(family = "Carlito")))

# Set up Victorian Electricity data set
source("velec.R")
```

```{css}
/* Adding here rather than in scss file to override an !important flag */
div.callout-note {
  border-left-color: #0063a7 !important;
}
div.callout-warning {
  border-left-color: #c14b14 !important;
}
```

```{r}
velec |>
  select(DateTime, Demand) |>
  tsbox::ts_xts() |>
  dygraph(main = "Victorian half-hourly electricity demand", ylab = "Demand (GW)") |>
  dyRangeSelector() |>
  dyOptions(colors = "#c14b14")
```

## Complex seasonality

```{r}
telec <- read_csv("https://robjhyndman.com/data/turkey_elec.csv", col_names = FALSE) |>
  rename(Demand = X1) |>
  mutate(
    Date = seq(as.Date("2000-01-01"), to = as.Date("2008-12-31"), by = "1 day"),
    Demand = Demand/1e3
  ) |>
  as_tsibble(index = Date)
telec |>
  tsbox::ts_xts() |>
  dygraph(main = "Turkish daily electricity demand", y = "Demand (GW)") |>
  dyRangeSelector() |>
  dyOptions(colors = "#c14b14")
```

## Complex seasonality

```{r}
us_gasoline |>
  tsbox::ts_xts() |>
  dygraph(main = "US finished motor gasoline product supplied", y = "Million barrels per day") |>
  dyRangeSelector() |>
  dyOptions(colors = "#c14b14")
```


## Complex seasonal topology

#### Example: hourly data

![](figs/topology.png)

## Complex seasonality

::: tightlist
-   Multiple seasonal periods, not necessarily nested
-   Non-integer seasonality
-   Irregular seasonal topography
-   Seasonality that depends on covariates
-   Complex seasonal topology
:::

> No existing decomposition method handles all of these.

. . .

::: {.callout-note icon="false"}
# Two solutions

1.  MSTL: For multiple integer seasonal periods.
2.  STR: For all types of complex seasonality.
:::

# MSTL

::: {.callout-note icon="false"}
# &nbsp;

-   Kasun Bandara, Rob J Hyndman, Christoph Bergmeir (2022) MSTL: A Seasonal-Trend Decomposition Algorithm for Time Series with Multiple Seasonal Patterns. *International J Operational Research*, to appear. [robjhyndman.com/publications/mstl/](https://robjhyndman.com/publications/mstl/)

-   Implemented in R packages `forecast` and `fable`.
:::

## MSTL

::: {layout-ncol="2"}
```{r mstl_elec, echo=TRUE, eval=FALSE}
velec |>
  model(STL(Demand)) |>
  components() |>
  autoplot()
```

::: {.shiftup}
```{r mstl_elec_out, ref.label="mstl_elec", echo=FALSE}
#| fig-height: 7.5
#| fig-width: 6
```
:::
:::


## MSTL

```{r}
decomp <- velec |>
  model(stl = STL(Demand)) |>
  components() |>
  tsbox::ts_xts()
dy_graph <- list(
  dygraph(decomp$stl_Demand, main="Demand", group="A", width=990, height=120),
  dygraph(decomp$stl_trend, main="Trend", group="A", width=990, height=120),
  dygraph(decomp$stl_season_year, main="Annual seasonality", group="A", width=990, height=120),
  dygraph(decomp$stl_season_week, main="Weekly seasonality", group="A", width=990, height=120),
  dygraph(decomp$stl_season_day, main="Daily seasonality", group="A", width=990, height=120),
  dygraph(decomp$stl_remainder, main="Remainder", group="A", width=990, height=120) |>
  dyRangeSelector(fillColor="", strokeColor="")
)
htmltools::browsable(htmltools::tagList(dy_graph))
```


## MSTL

$$y_t = T_t + \sum_{i=1}^I S_t^{(i)} + R_t$$

-   $I=$ number of seasonalities in $y_t$
-   $T_t=$ smooth trend component
-   $S_t^{(i)}=$ seasonal component $i$
-   $R_t=$ remainder component

## MSTL

```{r, eval=FALSE, echo=TRUE}
# X: time series object
# iterate: number of  STL iterations
# s.window: seasonal window values
# seas.ids: vector of seasonal periods in increasing order

seasonality <- matrix(0, nrow = nrow(X), ncol = length(seas.ids))
deseas <- X
for (j in 1:iterate) {
  for (i in 1:length(seas.ids)) {
    deseas <- deseas + seasonality[, i]
    fit <- model(
      STL(deseas ~ season(period = seas.ids[i], window = s.win[i]))
    ) %>%
      components()
    seasonality[, i] <- fit$season
    deseas <- deseas - seasonality[, i]
  }
}
trend <- fit$trend
remainder <- deseas - trend
return(trend, remainder, seasonality)
```

## MSTL

### fable syntax

``` r
tsibble |>
  model(STL(variable) ~ season(period = a, window = b) +
                        season(period = c, window = d))
```

<br><br>

### forecast syntax

``` r
vector |>
  msts(seasonal.periods = c(a, c)) |>
  mstl(s.window = c(b, d))
```

# STR

::: {.callout-note icon="false"}
# &nbsp;

-   Alex Dokumentov and Rob J Hyndman (2022) STR: Seasonal-Trend decomposition using Regression. *INFORMS Journal on Data Science*, to appear. [robjhyndman.com/publications/str/](https://robjhyndman.com/publications/str/)

-   Implemented in R package `stR`.
:::

## STR

$$
  y_{t} = T_{t} + \sum_{i=1}^{I} S^{(i)}_{t} + \sum_{p=1}^P \phi_{p,t} z_{t,p} + R_{t}
$$

  * $T_{t}=$ smooth trend component
  * $S^{(i)}_{t}=$ seasonal component $i$ (possibly complex topology)
  * $z_{p,t}=$ covariate with coefficient $\phi_{p,t}$ (possibly time-varying)
  * $R_{t}=$ remainder component

## Smoothness via difference operators

Smooth trend obtained by requiring $\Delta_2 T_t \sim \text{NID}(0,\sigma_L^2)$

  * $\Delta_2 = (1-B)^2$ where $B=$ backshift operator
  * $\sigma_L$ controls smoothness

. . .

$$f(\bm{D}_\ell \bm{\ell}) \propto \exp\left\{-\frac{1}{2}\big\|\bm{D}_\ell \bm{\ell} / \sigma_L\big\|_{L_2}^2\right\}$$

* $\bm{\ell} = \langle T_{t} \rangle_{t=1}^{n}$
* $\bm{D}_\ell=$ 2nd difference operator matrix: $\bm{D}_\ell\bm{\ell} = \langle\Delta^2 T_{t}\rangle_{t=3}^n$

## Smooth 2D seasonal surfaces

```{r, setup}
options(rgl.useNULL = TRUE)
library(rgl)
```

```{r, test-rgl, webgl=TRUE}
# 2d seasonal surface
knot <- cylinder3d(
  center = cbind(1:14, 0, 0),
  radius = 3,
  closed = FALSE
)
shade3d(addNormals(subdivision3d(knot, depth = 2)), col = "#0063a7")
x <- seq(1, 14, l = 500)
lines3d(x = x, y = 3 * sin(2 * pi * x/7), z = 3 * cos(2 * pi * x/7),
        lwd = 4, color = "#c14b14")
axis3d(edge = "x", at = seq(1.5, 13.5, l = 14), labels = 1:14)
text3d(x = 12, y = -4, z = -4, texts = "time t")
text3d(x = -4, y = 0, z = 0, texts = "season k")
text3d(x = 0, y = 3 * sin(2 * pi * (1:7)/7), z = 3 * cos(2 * pi * (1:7)/7),
       texts = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"))
text3d(x = 1:14, y = 3.3 * sin(2 * pi * (1:14)/7), z = 3.3 * cos(2 * pi * (1:14)/7),
       texts = rep(c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"), 2),
       col = "#c14b14", usePlotmath = TRUE)
rglwidget(height = 360)
```

  * $m_i=$ number of "seasons" in $S^{(i)}_{t}$.
  * $S^{(i)}_{k,t}=$ 2d season ($k=1,\dots,m_i;t=1,\dots,n$)
  * $\sum\limits_k S^{(i)}_{k,t} = 0$ for each $t$.

## Smooth 2D seasonal surfaces

* $\bm{S}^{(i)} = [S_{k,t}^{(i)}]$ the $i$th seasonal surface matrix
* $\bm{s}_i = \text{vec}(\bm{S}_i)=$ the $i$th seasonal surface in vector form

Smoothness in time $t$ direction:

::: smallequations
\begin{align*}
  \bm{D}_{tt,i} \bm{s}_i  &= \langle \Delta^2_{t} \bm{S}^{(i)}_{k,t} \rangle \sim \text{NID}(\bm{0},\sigma_{i}^2 \bm{\Sigma}_{i})\\
  f(\bm{s}_i) &\propto \exp\Big\{-\frac{1}{2}\big\|\ \bm{D}_{tt,i}\bm{s}_i / \sigma_i\big\|_{L_2}^2\Big\}
\end{align*}
:::

Analogous difference matrices $\bm{D}_{kk,i}$ and $\bm{D}_{kt,i}$ ensure smoothness in season and time-season directions.

## Gaussian remainders

* $R_{t} \sim \text{NID}(0,\sigma_R^2)$.
* $\bm{y} = [y_1,\dots,y_n]'=$ $vector of observations
* $\bm{Z}=[z_{t,p}]=$ covariate matrix with coefficient $\bm{\Phi} = [\phi_{p,t}]$
* $\bm{Q}_i=$  matrix that extracts $\langle S^{(i)}_{\kappa(t),t} \rangle_{t=1}^{n}$ from $\bm{s}_i$.
* Residuals: $\bm{r} = \bm{y} - \sum_i\bm{Q}_i\bm{s}_i -\bm{\ell} - \bm{Z}\bm{\Phi}$ have density
$$
  f(\bm{r}) \propto \exp\Big\{-\frac{1}{2}\big\|\bm{r}/\sigma_R\big\|_{L_2}^2\Big\},
$$

## MLE for STR {.smaller}

Minimize wrt $\bm{\Phi}$, $\bm{\ell}$ and $\bm{s}_i$:

::: smallequations
\begin{align*}
  -\log \mathcal{L} &= \frac{1}{2\sigma_R}
  \Bigg\{
    \Big\|
      \bm{y}- \sum_{i=1}^I \bm{Q}_i\bm{s}_i - \bm{\ell} - \bm{Z}\bm{\Phi}
    \Big\|_{L_2}^2  +
    \lambda_\ell\Big\|\bm{D}_\ell \bm{\ell}\Big\|_{L_2}^2 \\
  & \hspace*{1cm} + \sum_{i=1}^{I}\left(
      \left\|\lambda_{tt,i} \bm{D}_{tt,i} \bm{s}_i \right\|_{L_2}^2 +
      \left\|\lambda_{st,i} \bm{D}_{st,i} \bm{s}_i \right\|_{L_2}^2 +
      \left\|\lambda_{ss,i} \bm{D}_{ss,i} \bm{s}_i \right\|_{L_2}^2
    \right)
  \Bigg\}
\end{align*}
:::

:::: {.columns}

::: {.column width="32%"}
#### Equivalent to linear model

$$\bm{y}_{+} = \bm{X}\bm{\beta} + \bm{\varepsilon}$$

 * $\bm{y}_{+} = [\bm{y}',~ \bm{0}']'$
 * $\bm{\varepsilon} \sim N(\bm{0},\sigma_R^2\bm{I})$
:::

::: {.column width="68%" .smaller}
::: smallequations
$\bm{X} =
 \begin{bmatrix}
\bm{Q}_1                      & \dots   & \bm{Q}_I                      & \bm{I}_n                  & \bm{Z} \\
\lambda_{tt,1} \bm{D}_{tt,1}  & \dots   & 0                             & 0                         & 0 \\
\lambda_{st,1} \bm{D}_{st,1}  & \dots   & 0                             & 0                         & 0 \\
\lambda_{ss,1} \bm{D}_{ss,1}  & \dots   & 0                             & 0                         & 0 \\
0                             & \ddots  & 0                             & 0                         & 0 \\
0                             & \dots   & \lambda_{tt,I} \bm{D}_{tt,I}  & 0                         & 0 \\
0                             & \dots   & \lambda_{st,I} \bm{D}_{st,I}  & 0                         & 0 \\
0                             & \dots   & \lambda_{ss,I} \bm{D}_{ss,I}  & 0                         & 0 \\
0                             & \dots   & 0                             & \lambda_\ell \bm{D}_{tt}  & 0
\end{bmatrix}$
:::
:::
::::

## STR

```{r}
# Fit basic STR model
source("velec_str.R")
```

```{r}
#| fig-height: 7.5
#| fig-width: 6
names(velec_str_x$output$predictors) <- names(velec_str_x$input$predictors)
as_tsibble(velec_str_x$input$data) %>%
  rename(Demand = value) %>%
  mutate(
    Remainder = velec_str_x$output$random$data,
    Trend = velec_str_x$output$predictors$Trend$data,
    Season_year = velec_str_x$output$predictors$ASeason$data,
    Season_week = velec_str_x$output$predictors$WSeason$data,
    Season_day = velec_str_x$output$predictors$DSeason$data,
    Temperature = velec_str_x$output$predictors$Temp$data +
      velec_str_x$output$predictors$Tempsq$data,
  ) %>%
  as_dable(response = "Demand", aliases = rlang::exprs(Demand = Trend + Season_year + Season_week + Season_day + Temperature + Remainder), method = "STR") %>%
  autoplot() +
  theme(legend.position = "none") +
  xlab("Month") +
  theme_bw() +
  theme(legend.position = "none")
```


```{r}
#| eval: FALSE
#| fig-height: 7.5
#| fig-width: 6
as_tsibble(velec_str_x$input$data) %>%
  rename(Demand = value) %>%
  mutate(
    Remainder = velec_str_x$output$random$data,
    Trend = velec_str_x$output$predictors[[1]]$data,
    Season_year = velec_str_x$output$predictors[[4]]$data,
    Season_week = velec_str_x$output$predictors[[3]]$data,
    Season_day = velec_str_x$output$predictors[[2]]$data,
    Temperature = velec_str_x$output$predictors[[5]]$data
  ) %>%
  as_dable(response = "Demand", aliases = rlang::exprs(Demand = Trend + Season_year + Season_week + Season_day + Temperature + Remainder), method = "STR") %>%
  autoplot() +
  theme(legend.position = "none") +
  xlab("Month") +
  theme_bw() +
  theme(legend.position = "none")
```


```{r}
#| eval: FALSE
#| fig-height: 7.5
#| fig-width: 6
velec %>%
  mutate(
    Remainder = velec_str_x$output$random$data,
    Trend = velec_str_x$output$predictors[[1]]$data,
    Season_year = velec_str_x$output$predictors[[4]]$data,
    Season_week = velec_str_x$output$predictors[[3]]$data,
    Season_day = velec_str_x$output$predictors[[2]]$data,
    Temp = velec_str_x$output$predictors[[5]]$data,
    Tempsq = velec_str_x$output$predictors[[6]]$data,
  ) %>%
  select(DateTime, Demand, Trend, Season_year, Season_week, Season_day, Temp, Tempsq, Remainder) %>%
  as_dable(
    response = "Demand",
    aliases = rlang::exprs(Demand = Trend + Weekly + Daily + Temp + Tempsq + Remainder),
    method = "STR"
  )
p <- elec_dbl %>%
  autoplot() +
  xlab("Month") +
  geom_vline(data = outliers, aes(xintercept = DateTime), col = "gray") +
  ggplot2::theme_bw() + theme(legend.position = "none")
# Put vline behind data
p$layers <- p$layers[c(1, 4, 2, 3)]
p



```

```{r, eval=FALSE}
## Temperature plot highlighting outliers
# Find outliers
velec <- velec %>%
  mutate(res = elec_str$output$random$data)
outliers <- velec %>%
  filter(abs(res) >= sort(abs(velec$res))[NROW(velec) - 10 + 1])

velec %>%
  ggplot(aes(x = DateTime, y = Temp)) +
  geom_line() +
  geom_vline(data = outliers, aes(xintercept = DateTime), col = "red") +
  labs(y = "Temperature", x = "Date") +
  ggplot2::theme_bw()
```


```{r}
#| eval: FALSE



## Display table of outliers
outliers %>%
  mutate(
    Hour1 = hour(DateTime),
    Hour2 = hour(DateTime + 1800),
    Minute1 = minute(DateTime) %>% as.character(),
    Minute2 = minute(DateTime + 1800) %>% as.character(),
    Minute1 = if_else(Minute1 == "0", "00", Minute1),
    Minute2 = if_else(Minute2 == "0", "00", Minute2),
    Time = paste0(Hour1, ":", Minute1, " -- ", Hour2, ":", Minute2),
    Weekday = case_when(
      Weekday == "Thu" ~ "Thursday",
      Weekday == "Fri" ~ "Friday"
    ),
    Date = paste(day(Date), month(Date, label = TRUE, abbr = FALSE), year(Date)),
  ) %>%
  select(Date, Weekday, Time, res) %>%
  knitr::kable(
    format='latex',
    col.names = c("Date", "Day of week", "Time period", "Residual"),
    digits = 1, align = "rlcr", booktabs = TRUE, linesep=10,
    position="!bh",
    caption = "The ten residuals that are largest in absolute value after an STR decomposition."
  )
```

## For more information

**Slides:** [robjhyndman.com/seminars/compstat2002](https://robjhyndman.com/seminars/compstat2002)

::: {.callout-note icon="false"}
# Find me at:

`r fa("home")` [robjhyndman.com](https://robjhyndman.com)<br>
`r fa("twitter")` [\@robjhyndman](https://twitter.com/robjhyndman)<br>
`r fa("github")` [\@robjhyndman](https://github.com/robjhyndman)<br>
`r fa("envelope")` [rob.hyndman\@monash.edu](mailto:rob.hyndman@monash.edu)
:::
