---
title: "Decomposing time series with complex seasonality"
author: Rob J Hyndman
institute: "<img src='figs/monash_bw.png' width='25%'>"
abstract: "Time series data often contain a rich complexity of seasonal patterns. Time series that are observed at a sub-daily level can exhibit multiple seasonal patterns corresponding to different granularities such as hour-of-the-day, day-of-the-week or month-of-the-year. They can be nested (e.g., hour-of-the-day within day-of-the-week) and non-nested (e.g., day-of-the-year in both the Gregorian and Hijri calendars). I will discuss two new time series decomposition tools for handling seasonalities in time series data: MSTL and STR. These allow for multiple seasonal and cyclic components, covariates, seasonal patterns that may have non-integer periods, and seasonality with complex topology. They can be used for time series with any regular time index including hourly, daily, weekly, monthly or quarterly data, but tackle many more decomposition problems than other methods allow."
time: 20 mins
format:
  revealjs:
    slide-number: "c"
    preview-links: auto
    fig-format: svg
    controls: true
    theme: [default, custom.scss]
    html-math-method: katex
---

## Complex seasonality

```{r}
# Load packages needed later
library(tidyverse)
library(fpp3)
#library(stR)
library(gt)
library(fontawesome)
# Colours to be viridis for continuous scales and Okabe for discrete scales
options(
  digits = 4,
  ggplot2.continuous.colour="viridis",
  ggplot2.continuous.fill = "viridis",
  ggplot2.discrete.colour = c("#009E73", "#E69F00", "#56B4E9", "#F0E442","#CC79A7" ),
  ggplot2.discrete.fill = c("#009E73", "#E69F00", "#56B4E9", "#F0E442","#CC79A7" )
)
ggplot2::theme_set(theme_get() + theme(text = element_text(family = 'Carlito')))

velec <- vic_elec
minute(vvelec$DateTime) <- 0
velec <- velec %>%
  group_by(Time) %>%
  summarise(
    Date = min(Date),
    Demand = sum(Demand)/1e3,
    Temperature = mean(Temperature),
    Holiday = any(Holiday),
    .groups = "drop"
  ) %>%
  mutate(
    Period = as.numeric(Time - as_datetime(Date))/3600 + 12,
    Weekday = factor(weekdays(Date, abbreviate = TRUE),
      levels = c("Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun")
    ),
    WorkingDay = !Holiday & Weekday %in% c("Mon", "Tue", "Wed", "Thu", "Fri"),
    DailySeasonality = Period - 1,
    WeeklySeasonality = (as.integer(Weekday) - 1) * 48 + DailySeasonality,
    WorkingDay = !Holiday & Weekday %in% c("Mon", "Tue", "Wed", "Thu", "Fri"),
    WDSeasonality = (DailySeasonality + (!WorkingDay) * 100),
  ) %>%
  rename(DateTime = Time) %>%
  select(-Period) %>%
  select(DateTime, Date, Demand, everything()) %>%
  as_tsibble(index=DateTime)
```

```{css}
/* Adding here rather than in scss file to override an !important flag */
div.callout-note {
  border-left-color: #0063a7 !important;
}
div.callout-warning {
  border-left-color: #c14b14 !important;
}
```

```{r}
velec |>
  autoplot(Demand) +
  labs(title = "Victorian half-hourly electricity demand", y="Demand (GW)")
```

## Complex seasonality

```{r}
velec |>
  filter(Date >= "2014-01-01", Date <= "2014-03-31") |>
  autoplot(Demand) +
  labs(title = "Victorian half-hourly electricity demand", y="Demand (GW)")
```

## Complex seasonality

```{r}
telec <- read_csv("https://robjhyndman.com/data/turkey_elec.csv", col_names=FALSE) |>
  rename(Demand = X1) |>
  mutate(Date = seq(as.Date("2000-01-01"),to=as.Date("2008-12-31"), by="1 day")) |>
  as_tsibble(index=Date)
telec |>
  autoplot(Demand/1e3) +
  labs(title = "Turkish daily electricity demand", y = "Demand (GW)")
```

## Complex seasonality

```{r}
us_gasoline |>
  autoplot(Barrels) +
  labs(title = "US finished motor gasoline product supplied", y = "Million barrels per day")
```

## Complex seasonality

::: tightlist
-   Multiple seasonal periods, not necessarily nested
-   Non-integer seasonality
-   Irregular seasonal topography
-   Seasonality that depends on covariates
:::

> No existing decomposition method handles all of these.

. . .

::: {.callout-note icon="false"}
# Two solutions

1.  MSTL: For multiple integer seasonal periods.
2.  STR: For all types of complex seasonality.
:::

# MSTL

::: {.callout-note icon="false"}
#  

-   Kasun Bandara, Rob J Hyndman, Christoph Bergmeir (2022) MSTL: A Seasonal-Trend Decomposition Algorithm for Time Series with Multiple Seasonal Patterns. *International J Operational Research*, to appear. [robjhyndman.com/publications/mstl/](https://robjhyndman.com/publications/mstl/)

-   Implemented in R packages `forecast` and `fable`.
:::

## MSTL

::: {layout-ncol="2"}
```{r mstl_elec, echo=TRUE, eval=FALSE}
velec |>
  model(STL(Demand)) |>
  components() |>
  autoplot()
```

::: {.shiftup}
```{r mstl_elec_out, ref.label="mstl_elec", echo=FALSE}
#| fig-height: 7.5
#| fig-width: 6
```
:::
:::

## MSTL

$$y_t = S_t^1 + S_t^2 + \dots + S_t^n + R_t$$

-   $n=$ number of seasonalities in $y_t$
-   $S_t^i=$ seasonal component $i$
-   $R_t=$ remainder component

## MSTL

```{r, eval=FALSE, echo=TRUE}
# X: time series object
# iterate: number of  STL iterations
# s.window: seasonal window values
# seas.ids: vector of seasonal periods in increasing order

seasonality <- matrix(0, nrow=nrow(X), ncol=length(seas.ids))
deseas <- X
for (j in 1:iterate) {
  for (i in 1:length(seas.ids)) {
    deseas <- deseas + seasonality[,i]
    fit <- model(
        STL(deseas ~ season(period = seas.ids[i], window = s.win[i]))
      ) %>%
      components()
    seasonality[,i] <- fit$season
    deseas <- deseas - seasonality[,i]
  }
}
trend <- fit$trend
remainder <- deseas - trend
return(trend, remainder, seasonality)
```

## MSTL

### fable syntax

``` r
tsibble |>
  model(STL(variable) ~ season(period = a, window = b) +
                        season(period = c, window = d))
```

<br><br>

### forecast syntax

``` r
vector |>
  msts(seasonal.periods = c(a, c)) |>
  mstl(s.window = c(b, d))
```

# STR

::: {.callout-note icon="false"}
#  

-   Alex Dokumentov and Rob J Hyndman (2022) STR: Seasonal-Trend decomposition using Regression. *INFORMS Journal on Data Science*, to appear. [robjhyndman.com/publications/str/](https://robjhyndman.com/publications/str/)

-   Implemented in R package `stR`.
:::

## STR

```{r}
library(stR)
library(distributional)
# Create predictor dist object
predictor_dist <- function(x, level) {
  dist_percentile(
    with(x, mapply(c, data, split(lower, row(lower)), split(upper, row(upper)), SIMPLIFY = FALSE)),
    list(c(50, 50 + rep(c(-1, 1), each = length(level)) * rep(level, 2) / 2))
  )
}
velec_msts <- velec$Demand %>%
  forecast::msts(start = 2012, seasonal.periods=c(24, 24*7, 24*365))
decomp <- AutoSTR(velec_msts, confidence = 0.95)#, gapCV = 12, reltol = 0.00001)

as_tsibble(decomp$input$data) %>%
  rename(Demand = value) %>%
  mutate(
    Remainder = decomp$output$random$data,
    Trend = predictor_dist(decomp$output$predictors[[1]], 95),
    Season_year = predictor_dist(decomp$output$predictors[[4]], 95)
    Season_week = predictor_dist(decomp$output$predictors[[3]], 95),
    Season_day = predictor_dist(decomp$output$predictors[[2]], 95),
  ) %>%
  as_dable(response = "Demand", aliases = rlang::exprs(Demand = Trend + Season_year + Season_week + Season_day + Remainder), method = "STR") %>%
  autoplot(size = 0.5, fill = "blue", level = 95) +
  theme(legend.position = "none") +
  xlab("Month") +
  theme_bw() +
  theme(legend.position = "none")
```

## STR

```{r eval=FALSE}
# Set up predictors for STR
Predictors <- list()
Predictors$Trend <- list(
  name = "Trend",
  data = rep(1, NROW(velec)),
  times = velec$DateTime,
  seasons = rep(1, NROW(velec)),
  timeKnots = seq(from = first(velec$DateTime), to = last(velec$DateTime), length.out = 116),
  seasonalStructure = list(segments = list(c(0, 1)), sKnots = list(c(1, 0))),
  lambdas = c(1500, 0, 0)
)
Predictors$WSeason <- list(
  name = "Weekly seas",
  data = rep(1, NROW(velec)),
  times = velec$DateTime,
  seasons = velec$WeeklySeasonality,
  timeKnots = seq(from = first(velec$DateTime), to = last(velec$DateTime), length.out = 12),
  seasonalStructure = list(segments = list(c(0, 336)), sKnots = c(as.list(seq(4, 332, 4)), list(c(336, 0)))),
  lambdas = c(0.8, 0.6, 100)
)
Predictors$WDSeason <- list(
  name = "Daily seas",
  data = rep(1, NROW(velec)),
  times = velec$DateTime,
  seasons = velec$WDSeasonality,
  timeKnots = seq(from = first(velec$DateTime), to = last(velec$DateTime), length.out = 24),
  seasonalStructure = list(
    segments = list(c(0, 48), c(100, 148)),
    sKnots = c(as.list(c(1:47, 101:147)), list(c(0, 48, 100, 148)))
  ),
  lambdas = c(0.003, 0, 240)
)
Predictors$TrendTempM <- list(
  name = "Trend temp",
  data = velec$Temp,
  times = velec$DateTime,
  seasons = rep(1, NROW(velec)),
  timeKnots = Predictors$Trend$timeKnots,
  seasonalStructure = Predictors$Trend$seasonalStructure,
  lambdas = c(1e7, 0, 0)
)
Predictors$TrendTempM2 <- list(
  name = "Trend temp^2",
  data = velec$Temp^2,
  times = velec$DateTime,
  seasons = rep(1, NROW(velec)),
  timeKnots = Predictors$Trend$timeKnots,
  seasonalStructure = Predictors$Trend$seasonalStructure,
  lambdas = c(1e7, 0, 0)
)

# STR decomposition of electricity data
elec_str <- STR(
  data = velec$Demand,
  predictors = Predictors,
  confidence = 0.95, gapCV = 48 * 7
)

# Find outliers
velec <- velec %>%
  mutate(res = elec_str$output$random$data)
outliers <- velec %>%
  filter(abs(res) >= sort(abs(velec$res))[NROW(velec) - 10 + 1])

## Plot STR decomposition of electricity data

elec_dbl <- velec %>%
  as_tsibble(index = DateTime) %>%
  mutate(
    Remainder = elec_str$output$random$data,
    Trend = predictor_dist(elec_str$output$predictors[[1]], 95),
    Weekly = predictor_dist(elec_str$output$predictors[[2]], 95),
    Daily = predictor_dist(elec_str$output$predictors[[3]], 95),
    Temp = predictor_dist(elec_str$output$predictors[[4]], 95),
    Tempsq = predictor_dist(elec_str$output$predictors[[5]], 95),
  ) %>%
  select(DateTime, Demand, Trend, Weekly, Daily, Temp, Tempsq, Remainder) %>%
  as_dable(
    response = "Demand",
    aliases = rlang::exprs(Demand = Trend + Weekly + Daily + Temp + Tempsq + Remainder),
    method = "STR"
  )
p <- elec_dbl %>%
  autoplot(size = 0.5, fill = "blue", level = 95) +
  xlab("Month") +
  geom_vline(data = outliers, aes(xintercept = DateTime), col = "gray") +
  ggplot2::theme_bw() + theme(legend.position = "none")
# Put vline behind data
p$layers <- p$layers[c(1, 4, 2, 3)]
p



## Display table of outliers
outliers %>%
  mutate(
    Hour1 = hour(DateTime),
    Hour2 = hour(DateTime + 1800),
    Minute1 = minute(DateTime) %>% as.character(),
    Minute2 = minute(DateTime + 1800) %>% as.character(),
    Minute1 = if_else(Minute1 == "0", "00", Minute1),
    Minute2 = if_else(Minute2 == "0", "00", Minute2),
    Time = paste0(Hour1, ":", Minute1, " -- ", Hour2, ":", Minute2),
    Weekday = case_when(
      Weekday == "Thu" ~ "Thursday",
      Weekday == "Fri" ~ "Friday"
    ),
    Date = paste(day(Date), month(Date, label = TRUE, abbr = FALSE), year(Date)),
  ) %>%
  select(Date, Weekday, Time, res) %>%
  knitr::kable(
    format='latex',
    col.names = c("Date", "Day of week", "Time period", "Residual"),
    digits = 1, align = "rlcr", booktabs = TRUE, linesep=10,
    position="!bh",
    caption = "The ten residuals that are largest in absolute value after an STR decomposition."
  )


## Temperature plot highlighting outliers
velec %>%
  ggplot(aes(x = DateTime, y = Temp)) +
  geom_line() +
  geom_vline(data = outliers, aes(xintercept = DateTime), col = "red") +
  labs(y = "Temperature", x = "Date") +
  ggplot2::theme_bw()
```

## For more information

-   Slides: [robjhyndman.com/seminars/compstat2002](https://robjhyndman.com/seminars/compstat2002)
-   Source files: [github.com/robjhyndman/str_talk](https://github.com/robjhyndman/complex_seasonality_talk)

::: {.callout-note icon="false"}
# Find me at:

`r fa("home")` [robjhyndman.com](https://robjhyndman.com)<br> `r fa("twitter")` [\@robjhyndman](https://twitter.com/robjhyndman)<br> `r fa("github")` [\@robjhyndman](https://github.com/robjhyndman)<br> `r fa("envelope")` [rob.hyndman\@monash.edu](rob.hyndman@monash.edu)
:::
